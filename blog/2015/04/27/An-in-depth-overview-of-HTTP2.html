<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta content="width=device-width, initial-scale=1.0" name="viewport"> <meta content="" name="description"> <meta content="Stuart Douglas" name="author"> <title>An in depth overview of HTTP/2 Â· JBoss Community</title> <link href="https://static.jboss.org/theme/css/bootstrap-community/2.3.1.1/bootstrap-community.min.css" media="screen" rel="stylesheet"> <link href="https://undertow.io/stylesheets/code.css" rel="stylesheet" type="text/css"> <script src="https://undertow.io/javascripts/highlight.pack.js" type="text/javascript"></script> <script type="text/javascript">hljs.initHighlightingOnLoad();</script> <!--[if lt IE 9]><script src="https://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script><![endif]--> <link href="https://undertow.io/images/undertow_icon_16px.png" rel="shortcut icon"> <link href="https://static.jboss.org/images/example/apple-touch-icon-144x144-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144"> <link href="https://static.jboss.org/images/example/apple-touch-icon-114x114-precomposed.png" rel="apple-touch-icon-precomposed" sizes="114x114"> <link href="https://static.jboss.org/images/example/apple-touch-icon-72x72-precomposed.png" rel="apple-touch-icon-precomposed" sizes="72x72"> <link href="https://static.jboss.org/images/example/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed"> <style>
  @media (min-width: 651px) {
      .banner { background-image: url(https://undertow.io/images/undertow_banner.png); height: 110px;  }
  }
  @media (max-width: 650px) {
      .banner { width: 200px; margin: 0px auto; }
  }
</style> <script src="https://static.jboss.org/theme/js/libs/jquery/jquery-1.9.1.min.js"></script> </head> <body> <div class="container" id="content"> <div class="dropup"> <a class="tabnav-closed" href="https://www.redhat.com" id="tab">Red Hat</a> </div> <div class="banner"> </div> <div class="navbar navbar-inverse" id="navbar-fix"> <div class="navbar-inner"> <div class="container"> <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </a> <div class="nav-collapse collapse"> <ul class="nav"> <li class=""><a href="https://undertow.io/index.html">Home</a></li> <li class="active"><a href="https://undertow.io/blog/index.html">Blog</a></li> <li class=""><a href="https://undertow.io/downloads.html">Download</a></li> <li class=""><a href="https://undertow.io/documentation.html">Documentation</a></li> <li class=""><a href="https://undertow.io/get-involved.html">Get Involved</a></li> <li class="divider"></li> </ul> </div> </div> </div> </div> <h2 class="title">An in depth overview of HTTP/2</h2> <div class="sect1"> <h2 id="_introduction">Introduction</h2> <div class="sectionbody"> <div class="paragraph"> <p>HTTP/2 is a new protocol, intended as a higher performance alternative to HTTP/1.1. It introduces several new features, while remaining semantically compatible.</p> </div> </div> </div> <div class="sect1"> <h2 id="_key_features">Key Features</h2> <div class="sectionbody"> <div class="paragraph"> <p>HTTP/2 has the following key features compared to HTTP/1.1:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1">Binary Protocol</dt> <dd> <p>HTTP/2 is a binary protocol. This means that it is much more efficient on the wire, however as a result it is no longer human readable without using tools to decode the protocol.</p> </dd> <dt class="hdlist1">Multiplexing</dt> <dd> <p>HTTP/2 supports multiplexing several streams over a single connection. This means that a client can send multiple requests on the same connection, and the server can respond in whatever order the responses become available.</p> </dd> <dt class="hdlist1">Header Compression</dt> <dd> <p>HTTP requests and responses generally include a large number of redundant headers. HTTP/2 uses HPACK header compression to greatly compress headers.</p> </dd> <dt class="hdlist1">Server Push</dt> <dd> <p>Server push allows a server to send additional cacheable resources to the client that the client has not explicitly asked for. The allows the server to anticipate the resources the client will request next and send them eagerly, which saves a round trip.</p> </dd> </dl> </div> </div> </div> <div class="sect1"> <h2 id="_connection_establishment">Connection Establishment</h2> <div class="sectionbody"> <div class="paragraph"> <p>The first part of any usage of HTTP/2 is connection establishment. It would not be practical to allocate a new port just for HTTP/2 for various reasons, so instead the protocol defines 3 different methods of connection that allow the existing HTTP and HTTPS ports to be re-used.</p> </div> <div class="ulist"> <ul> <li> <p>ALPN based connection for https:// URIs</p> </li> <li> <p>HTTP upgrade based connection http:// URIs</p> </li> <li> <p>Connection via prior knowledge for hosts which are known to support HTTP/2</p> </li> </ul> </div> <div class="paragraph"> <p>A detailed explanation of the three is given below. Once the initial connection has been established both the client and server send a connection preface, after which the connection is established.</p> </div> <div class="sect2"> <h3 id="_http_2_connection_methods">HTTP/2 Connection methods</h3> <div class="dlist"> <dl> <dt class="hdlist1">ALPN based connection for https:// URIs</dt> <dd> <p><a href="https://tools.ietf.org/html/rfc7301">ALPN</a> stands for <em>Application Layer Protocol Negotiation</em>, and is a TLS extension that allows a client to negotiate the next protocol to use after the TLS handshake is complete. If either the client or the server does not support ALPN, then it will be ignored, and HTTP/1.1 will be used instead.</p> <div class="literalblock"> <div class="content"> <pre>When the client connects to the server it sends a list of supported protocols. The server will then decide on the next&#x000A;protocol to use and send this back in its response. If the server decides to use HTTP/2 it will send pack 'h2' as the&#x000A;selected protocol, and HTTP/2 will be used for the connection.</pre> </div> </div> </dd> <dt class="hdlist1">HTTP upgrade based connection http:// URIs</dt> <dd> <p>When using this method a client sends a HTTP/1.1 request as normal, however it includes an <code>Upgrade: h2c</code> header that indicates to the server that it wishes to upgrade the connection to HTTP/2.</p> <div class="literalblock"> <div class="content"> <pre>If the server does not understand HTTP/2 or for whatever reason does not wish to use it, it will simply ignore the upgrade&#x000A;request and send a normal HTTP/1.1 response. If the server does decide to upgrade to HTTP/2 then it sends back a HTTP/1.1&#x000A;101 (switching protocols) response, and then after connection establishment has completed sends the response to the&#x000A;original request using HTTP/2.</pre> </div> </div> <div class="literalblock"> <div class="content"> <pre>A client connecting using this method must also include a `HTTP2-Settings` header field, which contains a base 64&#x000A;encoded HTTP/2 settings frame (more on this later).</pre> </div> </div> <div class="literalblock"> <div class="content"> <pre>(NOTE: Firefox and Chrome have both publicly stated that they are not going to support this method, so it remains to be&#x000A; seen if this method will see much real world use).</pre> </div> </div> </dd> <dt class="hdlist1">Connection via prior knowledge for hosts which are known to support HTTP/2</dt> <dd> <p>If it is known that a given host supports HTTP/2 then a client can connect directly by sending a HTTP/2 connection preface. This connection preface is covered in detail below, but it essentially follows the format of HTTP request with <code>PRI</code> as the request method and <code>HTTP/2.0</code> as the protocol, which allows HTTP/1.1 servers to parse it normally. It is not expected that this method will be used on the open internet, however it has its uses (e.g. the Undertow reverse proxy implementation will use it to connect to backend server it knows support HTTP/2).</p> </dd> </dl> </div> </div> <div class="sect2"> <h3 id="_http_2_connection_preface">HTTP/2 connection preface</h3> <div class="paragraph"> <p>Once the initial connection has been established both the client and the server must send a connection preface. The client sends the string <code>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code>, followed by HTTP/2 <code>SETTINGS</code> frame, which may be empty.</p> </div> <div class="paragraph"> <p>The server must send a <code>SETTINGS</code> frame (which may be empty).</p> </div> <div class="paragraph"> <p>Once the connection preface has been exchanged the connection is considered established, and the endpoints can use it to communicate.</p> </div> </div> </div> </div> <div class="sect1"> <h2 id="_wire_format">Wire Format</h2> <div class="sectionbody"> <div class="paragraph"> <p>This post will not go into a in-depth discussion of the wire format, instead we will just give an overview of the basic concepts (if you more details I highly recommend going directly to the <a href="https://http2.github.io/">specification</a>).</p> </div> <div class="paragraph"> <p>HTTP/2 is a framed protocol. All data that is send is part of a frame, which consists of a frame header, followed by some frame data, the format of which depends on the frame type. The maximum size of a frame is 2^24-1 (16,777,215) octets.</p> </div> <div class="paragraph"> <p>A frame header contains the following information:</p> </div> <div class="ulist"> <ul> <li> <p>The frame length</p> </li> <li> <p>The frame type</p> </li> <li> <p>Flags</p> </li> <li> <p>Stream identifier</p> </li> </ul> </div> <div class="paragraph"> <p>The specification defines the following frame types:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1"><code>DATA</code></dt> <dd> <p>Carries the data in a request or response.</p> </dd> <dt class="hdlist1"><code>HEADERS</code></dt> <dd> <p>Used to open a stream (i.e. start a request or response), it contains the headers associated with the request or response</p> </dd> <dt class="hdlist1"><code>PRIORITY</code></dt> <dd> <p>Used to set the priority of a stream</p> </dd> <dt class="hdlist1"><code>RST_STREAM</code></dt> <dd> <p>Forcibly terminates a stream, this is only used if one endpoint decides to cancel a stream, it is not used for normal stream termination</p> </dd> <dt class="hdlist1"><code>SETTINGS</code></dt> <dd> <p>Establishes connection settings for the HTTP/2 connection</p> </dd> <dt class="hdlist1"><code>PUSH_PROMISE</code></dt> <dd> <p>Sent by the server to push a response to the client</p> </dd> <dt class="hdlist1"><code>PING</code></dt> <dd> <p>Sends a ping to the remote endpoint, which must respond with a ping of its own</p> </dd> <dt class="hdlist1"><code>GOAWAY</code></dt> <dd> <p>Sent when an endpoint is going to close the connection</p> </dd> <dt class="hdlist1"><code>WINDOW_UPDATE</code></dt> <dd> <p>Updates the flow control window</p> </dd> <dt class="hdlist1"><code>CONTINUATION</code></dt> <dd> <p>Used to send additional headers if the headers are too large to fit in a single <code>HEADERS</code> frame</p> </dd> </dl> </div> <div class="paragraph"> <p>It is also possible for extensions to define new frame types. An endpoint that does not understand a frame type must simply discard the frame, rather than treating it as an error.</p> </div> </div> </div> <div class="sect1"> <h2 id="_multiplexing">Multiplexing</h2> <div class="sectionbody"> <div class="paragraph"> <p>In HTTP/1.1 requests are essentially processed one at a time. A client sends a request to a server, which generates a response, and once the client has received the response it can send another request to the server. This is not great from a performance point of view. Because only one resource can be requested at a time a single slow resource can delay the rendering of a page. It also does not allow for multiple resources to be generated at the same time.</p> </div> <div class="paragraph"> <p>As a result there are lots of workaround that are used on both the server and browser side to improve performance, including:</p> </div> <div class="ulist"> <ul> <li> <p>Browsers opening multiple connections per host, so multiple resources can requested at once</p> </li> <li> <p>Spriting, where a page with multiple images merges them into a single image, and CSS is used to control the part of the image that is displayed</p> </li> <li> <p>Domain sharding, where resources are served from different subdomains, which allows the browser to open more connections as the browsers internal connection limit is applied per domain</p> </li> <li> <p>HTTP pipelining, where requests are send before responses are relieved, so the server can begin processing them immediately once the current response is done</p> </li> </ul> </div> <div class="paragraph"> <p>HTTP/2 avoids these issues, through the use of multiplexing. This allows multiple requests to be active at once, and the responses can be interleaved on the wire as they become available.</p> </div> <div class="paragraph"> <p>This is done through the concept of streams, in HTTP/2 every request/response pair is mapped to a stream. Each stream is given a unique id. Streams started by the client (most streams) must use odd numbers for the stream identifier, while streams initiated by the server (server push) use even identifiers. Streams are initiated by a <code>HEADERS</code> frame from the client, or a <code>PUSH_PROMISE</code> frame from the server. All HTTP/2 frames include a stream identifier in the header, which allows an endpoint to determine which request the frame belongs to. By default there is no limit to the number of concurrent streams that can be active on a connection, although the server can impose a limit using a <code>SETTINGS</code> frame to limit the amount of server resources a single client can consume.</p> </div> </div> </div> <div class="sect1"> <h2 id="_request_response_overview">Request/Response Overview</h2> <div class="sectionbody"> <div class="paragraph"> <p>At its core HTTP/2 is still a request oriented protocol. A client sends the server a request, the server generates a response and sends it back (server push is obviously an exception to this). This means that it maps cleanly to HTTP/1.1 semantics, so in many cases the application code that is processing a request does not need to know which version of HTTP the wire protocol is using.</p> </div> <div class="paragraph"> <p>A request is started by a client sending a <code>HEADERS</code> frame to open a stream. As you would expect from the name this contains normal HTTP request headers, however it also contains the following pseudo headers:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1"><code>:method</code></dt> <dd> <p>The request method</p> </dd> <dt class="hdlist1"><code>:path</code></dt> <dd> <p>The request path</p> </dd> <dt class="hdlist1"><code>:scheme</code></dt> <dd> <p>The request scheme. Usually either <code>http</code> or <code>https</code></p> </dd> <dt class="hdlist1"><code>:authority</code></dt> <dd> <p>Similar to the HTTP/1.1 <code>Host:</code> header, this contains the authority portion of the target URI (e.g. <a href="http://example.com" class="bare">http://example.com</a>)</p> </dd> </dl> </div> <div class="paragraph"> <p>These pseudo headers must be present and the first headers in the frame. After this the <code>HEADERS</code> frame can contain any number of request headers. If the number of request headers exceeds the maximum frame size then the client can immediately send <code>CONTINUATION</code> frames with additional headers. The last frame containing headers will have the <code>END_HEADERS</code> flag set, which tells the remote endpoint that there is no more headers.</p> </div> <div class="paragraph"> <p>The request can also contain data (e.g. POST requests). If the request has no data the initial <code>HEADERS</code> frame will have the <code>END_STREAM</code> flag set, which tells the server there is no data. Otherwise the server will expect the client to send any number of <code>DATA</code> frames, with the <code>END_STREAM</code> flag set on the last one.</p> </div> <div class="paragraph"> <p>When the server is ready to send a response sequence of frames is similar to when the client sends a request, a single <code>HEADERS</code> frame, followed by optional <code>CONTINUATION</code> frames if the headers do not fit in a single frame, followed by <code>DATA</code> frames for the entity body, however in this case the only pseudo header field is <code>:status</code>, which carries the response status code.</p> </div> <div class="paragraph"> <p>Note that because of the framed structure of HTTP/2 it is no longer necessary (in fact explicitly forbidden) to use the chunked transfer encoding that HTTP/1.1 uses for entities of unknown lengths. If the content length is known it is still recommended to send it in a <code>Content-Length</code> header, even though it is no longer required for the client to know when the request is done it makes for a more user friendly experience (as if this is not present it is not possible for a client to display download progress).</p> </div> </div> </div> <div class="sect1"> <h2 id="_hpack">HPACK</h2> <div class="sectionbody"> <div class="paragraph"> <p>HTTP/2 introduces a form of header compression called HPACK. HPACK allows for very efficient header compression, without being vulnerable to compression related attacks such as CRIME. HPACK provides the following:</p> </div> <div class="ulist"> <ul> <li> <p>The ability to encode large headers using a fixed Huffman encoding</p> </li> <li> <p>The ability to encode commonly used headers as a variable length integer, rather than re-sending the whole header each time</p> </li> </ul> </div> <div class="paragraph"> <p>All headers sent via HTTP/2 (in <code>HEADERS</code>, <code>CONTINUATION</code> and <code>PUSH_PROMISE</code> frames) are sent in the HPACK format.</p> </div> <div class="paragraph"> <p>HPACK works by having both endpoints maintain a copy of a header table (the <em>dynamic table</em>). When an endpoint sends a header to the remote endpoint it can instruct the remote endpoint to store it in its dynamic table. If the endpoint needs to send the same header again it can just send its index in the dynamic table, instead of sending the whole header. The size of the dynamic table is limited to 4k by default, however larger or smaller limits can be set using a <code>SETTINGS</code> frame.</p> </div> <div class="paragraph"> <p>As many requests and responses will contain the same headers, this technique is very effective, as after the first request most headers will be represented as an integer index into the dynamic or static table.</p> </div> <div class="paragraph"> <p>HPACK also defines a <em>static table</em> which is a pre defined table of commonly used headers, so HPACK will provide some compression even before the dynamic table is populated.</p> </div> <div class="paragraph"> <p>HPACK also allows header names and values to be encoded via a fixed Huffman encoding. Because this encoding uses a fixed encoding table, it is not vulnerable to compression based attacks such as CRIME.</p> </div> </div> </div> <div class="sect1"> <h2 id="_server_push">Server Push</h2> <div class="sectionbody"> <div class="paragraph"> <p>First introduced in the SPDY protocol, server push allows a server to send unsolicited request+response pairs to a client. Generally this will be used to immediately begin sending resources that a server expects a client based on the current request. For example if a client requests <code>/index.html</code>, and the server knows that <code>/index.html</code> contains a reference to <code>/logo.png</code> the server might decide to immediately push <code>logo.png</code> rather than waiting for the client to request it.</p> </div> <div class="paragraph"> <p>To push a response to the client the server opens a stream using a <code>PUSH_PROMISE</code> frame, which contains the complete set of request header fields that the server attributes to the request (this includes pseudo headers, such as <code>:path</code>, which let the client know exactly which resource is being pushed). A <code>PUSH_PROMISE</code> frame must be associated with an existing client request, so the client knows which request caused the server to initiate the push. After the <code>PUSH_PROMISE</code> frame has been send the server may begin sending <code>HEADERS</code> followed by <code>DATA</code> frames, as it would for a normal response.</p> </div> <div class="paragraph"> <p>Pushed resources must be <a href="http://tools.ietf.org/html/rfc7234">cacheable</a>. In practice this means that pushed requests will generally be limited to <code>GET</code> requests with a response that contains headers that allow for caching.</p> </div> <div class="paragraph"> <p>If a server pushes a request for a resource that the client knows it does not need (for example it may already have the resource in its cache) the client can send a <code>RST_STREAM</code> frame to the server to cancel the pushed request.</p> </div> <div class="paragraph"> <p>Note that there is no foolproof way to know exactly what should be pushed, as there is know way to know exactly what a client has in its cache. Initiating a large number of pushes for resources that the client already has cached is obviously not ideal, as it can waste server resources and bandwidth (even if the client does <code>RST_STREAM</code> the pushed request, the server will may have already allocated resources to servicing the push request).</p> </div> </div> </div> <div class="sect1"> <h2 id="_priority">Priority</h2> <div class="sectionbody"> <div class="paragraph"> <p>Priority is a new concept that HTTP/2 introduces to allow a client to give priority preferences to particular streams. Priority is non binding, and a server is free to ignore it completely.</p> </div> <div class="paragraph"> <p>The priority mechanism is expressed in terms of stream dependencies and weights. A stream can be given a dependency on another stream, which tells the server that it should allocate resources to the identified stream instead of the dependent stream (conceptually all streams are considered to depend on another stream, streams with no explicit dependency depend on the virtual stream 0).</p> </div> <div class="paragraph"> <p>According to the spec a server should only allocate resources to a dependent stream if all its dependencies (and their dependencies) are either closed or it is not possible to make progress on them.</p> </div> <div class="paragraph"> <p>Dependent streams can also be given a weight, between 1 and 256, and resources should be allocated on a proportional basis. For example if stream A and B have a dependency on C, and A has a weighting of 1 and B has a weighting of 10 then B should receive 10 times amount of server resources as A.</p> </div> <div class="paragraph"> <p>Dependencies and weightings can be set at stream creation time, and modified afterwards with a <code>PRIORITY</code> frame.</p> </div> <div class="paragraph"> <p>Note that due to the complexity of implementing this on the server side it is unlikely that many implementations will be able to allocate resources and prioritise as the spec specifies. In general once a request has started being processed in most cases a server does not have control over how CPU and other resources (database connection etc) are processed. In practice servers will likely be able to prioritise frames from higher priority streams if multiple frames are ready at the same time, and if streams are being queued for execution processes higher priority streams over lower priority ones, but in general a client cannot rely on priority as being anything other than a suggestion.</p> </div> </div> </div> <div class="sect1"> <h2 id="_flow_control">Flow Control</h2> <div class="sectionbody"> <div class="paragraph"> <p>HTTP/2 has the concept of a credit based flow control mechanism. Every stream, and the connection as a whole maintains a send window, which is the amount of data that the server is allowed to send on the stream/connection. Once this window is exhausted no more data can be sent, until the remote endpoint sends a <code>WINDOW_UPDATE</code> frame that increases the send window size. This additional flow control window is on top of the flow control already provided by TCP. The default window size is 65,535 bytes, however many implementation will increase this in the initial <code>SETTINGS</code> frame. Flow control only applies to <code>DATA</code> frames.</p> </div> <div class="paragraph"> <p>To understand why this is necessary consider a server handling a large POST request from a client. The server basically acts as an intermediary between the network and some web application, if the web application is slow to read this POST data, then as a server we only have two options:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1">Buffer a potentially unbounded amount of data</dt> <dd> <p>In this scenario the client keeps sending data, and we keep storing it in memory waiting for the web application to ask for it. This has the potential for a misbehaving or malicious client to make the server run out of memory.</p> </dd> <dt class="hdlist1">Stop reading from the underlying socket</dt> <dd> <p>Once we have buffered a certain amount of data we could simply stop reading from the underlying socket until the end user application empties the buffer. Unfortunately this means that all other requests will also be blocked (head of line blocking), which negates a lot of the benefits of multiplexing.</p> </dd> </dl> </div> <div class="paragraph"> <p>Flow control allows us to limit the amount of data that is sent for any given stream, essentially allowing us to pause the stream until the web application actually starts reading data. If we don&#8217;t send <code>WINDOW_UPDATE</code> frames for a stream until the web application has actually consumed the data then we know that the maximum amount of data we will need to buffer per stream is equivalent to the window size (which we can control through a <code>SETTINGS</code> frame).</p> </div> <div class="paragraph"> <p>Without flow control an endpoint has no effective way of managing the amount of data it may need to buffer.</p> </div> <div class="paragraph"> <p>Something to note is that the flow control window can be different in each direction. For example a resource constrained server may set a small flow control window size to prevent the client from flooding it with a large amount of data, while the client may set a large flow control window for maximum performance. In this case the server can send a large amount of data before receiving a <code>WINDOW_UPDATE</code>, while the client will only be able to send a small amount.</p> </div> <div class="paragraph"> <p>Note that flow control should not be used as a priority mechanism (HTTP/2 already has the concept of stream priority for this). In particular a deadlock can result if a client stops sending <code>WINDOW_UPDATE</code> frames on a stream1 because it wants a server to prioritise stream2, and the server has decided not to allocate resources to stream2 until stream1 is complete.</p> </div> </div> </div> <div class="sect1"> <h2 id="_settings">Settings</h2> <div class="sectionbody"> <div class="paragraph"> <p>The HTTP/2 settings frame is used to establish settings that are used to control each side of the connection. Each endpoint sends its own settings, which may be different which means the settings may be different for depending on the direction of communication (e.g. the maximum frame size can be different depending on if they are sent by the client or the server).</p> </div> <div class="paragraph"> <p>The specification defines the following settings:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1"><code>SETTINGS_HEADER_TABLE_SIZE</code></dt> <dd> <p>The maximum allowed size of the HPACK header table. Defaults to 4,096.</p> </dd> <dt class="hdlist1"><code>SETTINGS_ENABLE_PUSH</code></dt> <dd> <p>A setting that is sent from the client to the server, if this is enabled then the server is allowed to push responses to the client, default to true.</p> </dd> <dt class="hdlist1"><code>SETTINGS_MAX_CONCURRENT_STREAMS</code></dt> <dd> <p>The maximum number of concurrent streams that can be opened, basically this corresponds to the number of requests that can be active at the same time. By default this is unlimited.</p> </dd> <dt class="hdlist1"><code>SETTINGS_INITIAL_WINDOW_SIZE</code></dt> <dd> <p>The initial window size that is used for flow control. Defaults to 65,535.</p> </dd> <dt class="hdlist1"><code>SETTINGS_MAX_FRAME_SIZE</code></dt> <dd> <p>The maximum allowed frame size that the remote endpoint is prepared to accept. Defaults to 16,384.</p> </dd> <dt class="hdlist1"><code>SETTINGS_MAX_HEADER_LIST_SIZE</code></dt> <dd> <p>This setting advises the remote endpoint of the maximum size of the header list the remote endpoint will accept. The default value is unlimited.</p> </dd> </dl> </div> </div> </div> <div id="companyfooter-placeholder"></div> </div> <div class="container" id="companyfooter"> <div class="redhatlogo"> <div id="logospacer"></div> <a href="https://www.redhat.com/"><img src="https://static.jboss.org/theme/images/common/redhat_logo.png"></a> </div> </div> <script src="https://static.jboss.org/wildfly/scripts/bootstrap-community.min.js"></script> <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-61374382-1', 'auto');
  ga('send', 'pageview');
</script> </body> </html>