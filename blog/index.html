<!DOCTYPE html> <html lang="en"> <head> <meta charset="utf-8"> <meta content="width=device-width, initial-scale=1.0" name="viewport"> <meta content="" name="description"> <meta content="" name="author"> <title>Undertow Blog · JBoss Community</title> <link href="https://static.jboss.org/theme/css/bootstrap-community/2.3.1.1/bootstrap-community.min.css" media="screen" rel="stylesheet"> <link href="https://undertow.io/stylesheets/code.css" rel="stylesheet" type="text/css"> <script src="https://undertow.io/javascripts/highlight.pack.js" type="text/javascript"></script> <script type="text/javascript">hljs.initHighlightingOnLoad();</script> <!--[if lt IE 9]><script src="https://static.jboss.org/theme/js/libs/html5/pre3.6/html5.min.js"></script><![endif]--> <link href="https://undertow.io/images/undertow_icon_16px.png" rel="shortcut icon"> <link href="https://static.jboss.org/images/example/apple-touch-icon-144x144-precomposed.png" rel="apple-touch-icon-precomposed" sizes="144x144"> <link href="https://static.jboss.org/images/example/apple-touch-icon-114x114-precomposed.png" rel="apple-touch-icon-precomposed" sizes="114x114"> <link href="https://static.jboss.org/images/example/apple-touch-icon-72x72-precomposed.png" rel="apple-touch-icon-precomposed" sizes="72x72"> <link href="https://static.jboss.org/images/example/apple-touch-icon-precomposed.png" rel="apple-touch-icon-precomposed"> <style>
  @media (min-width: 651px) {
      .banner { background-image: url(https://undertow.io/images/undertow_banner.png); height: 110px;  }
  }
  @media (max-width: 650px) {
      .banner { width: 200px; margin: 0px auto; }
  }
</style> <script src="https://static.jboss.org/theme/js/libs/jquery/jquery-1.9.1.min.js"></script> </head> <body> <div class="container" id="content"> <div class="dropup"> <a class="tabnav-closed" href="https://www.redhat.com" id="tab">Red Hat</a> </div> <div class="banner"> </div> <div class="navbar navbar-inverse" id="navbar-fix"> <div class="navbar-inner"> <div class="container"> <a class="btn btn-navbar" data-target=".nav-collapse" data-toggle="collapse"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </a> <div class="nav-collapse collapse"> <ul class="nav"> <li class=""><a href="https://undertow.io/index.html">Home</a></li> <li class="active"><a href="https://undertow.io/blog/index.html">Blog</a></li> <li class=""><a href="https://undertow.io/downloads.html">Download</a></li> <li class=""><a href="https://undertow.io/documentation.html">Documentation</a></li> <li class=""><a href="https://undertow.io/get-involved.html">Get Involved</a></li> <li class="divider"></li> </ul> </div> </div> </div> </div> <article class="post"> <header class="header"> <h2 class="title"> <a href="/blog/2020/05/05/Undertow-2.html">Undertow 2.1.0.Final Released</a> </h2> <div class="byline"> <span class="dateinline">on May 05, 2020</span> </div> </header> <div class="body"> <div class="paragraph"> <p>A couple of weeks ago we released Undertow 2.1.0.Final, and now it is part of the new <a href="https://wildfly.org/news/2020/05/04/WildFly-1910-Released/">WildFly 19.1.0.Final</a>!</p> </div> <div class="paragraph"> <p>Undertow 2.1.0.Final comes with a new predicate handler: <a href="http://undertow.io/javadoc/2.1.x/io/undertow/server/handlers/SameSiteCookieHandler.html">samesite-cookie</a>.</p> </div> <div class="paragraph"> <p>This handler can be used to automatically add the <code>SameSite</code> attribute to cookies in your application, making it compatible with the latest draft for <a href="https://tools.ietf.org/html/draft-west-cookie-incrementalism-01">Incrementally Better Cookies</a> spec.</p> </div> <div class="paragraph"> <p>Several clients support the new spec, and that means that your cookies without a <code>SameSite</code> attribute will be treated like a <code>SameSite=Lax</code> cookie, limiting your cookie to be sent to same-site requests and top-level cross-site navigations as specificed <a href="https://tools.ietf.org/html/draft-ietf-httpbis-rfc6265bis-03#section-5.3.7.1">here</a>. Whether this is the desired behavior for your cookie or if you want it to have one of the other two values for <code>SameSite</code> (<code>None</code> or <code>Strict</code>), it is a good practice to explicitly define the <code>SameSite</code> attribute in your cookies. This can be achieved via <code>samesite-cookie</code> handler:</p> </div> <div class="paragraph"> <p>The handler can be used in the same way any other predicate handler, in the form <code>predicate&#8594;handler</code>:</p> </div> <div class="listingblock"> <div class="content"> <pre>path(/app2)-&gt;samesite-cookie(`None`)</pre> </div> </div> <div class="paragraph"> <p>The predicate above will apply <code>SameSite=None</code> attribute to all cookies set when handling requests to the path <code>/app2</code>. As <code>None</code> is not <a href="https://www.chromium.org/updates/same-site/incompatible-clients">supported by all clients</a> the handler applies a client checker that skips the attribute if the client is not compatible.</p> </div> <div class="paragraph"> <p>This client check is enabled by default, but can be explicitly enabled or disabled via <code>enable-client-checker</code> parameter:</p> </div> <div class="listingblock"> <div class="content"> <pre>path(/app2)-&gt;samesite-cookie(mode=None, enable-client-checker=false)</pre> </div> </div> <div class="paragraph"> <p><a href="https://tools.ietf.org/html/draft-west-cookie-incrementalism-01#section-3.2">Session 3.2 of Incrementally Better Cookies</a> also makes it mandatory for cookies that have <code>SameSite=None</code> to have the <code>Secure</code> attribute. This is done automatically by the handler unless <code>add-secure-for-none=false</code> parameter is specified.</p> </div> <div class="paragraph"> <p>Finally, the handler can be used in a finer grained way if desired, via the optional <code>cookie-pattern</code> parameter, that expects a cookie name regex. The example below adds <code>SameSite=Lax</code> to all cookies whose name start with <code>abc</code>:</p> </div> <div class="listingblock"> <div class="content"> <pre>path(/app2)-&gt;samesite-cookie(mode=Lax, cookie-pattern=abc*)</pre> </div> </div> <div class="paragraph"> <p>Besides the new handler, we have added several fixes to the project and updated dependencies to the latest.</p> </div> <div class="paragraph"> <p>A full list of Jiras can be viewed <a href="https://issues.redhat.com/projects/UNDERTOW/versions/12344252">here</a>. I hope you all enjoy the new Undertow release!</p> </div> </div> <div class="footer"> <a href="/blog/2020/05/05/Undertow-2.html">permalink</a> </div> </article> <article class="post"> <header class="header"> <h2 class="title"> <a href="/blog/2019/04/15/Undertow-3.html">Undertow 3.0 Announcement</a> </h2> <div class="byline"> <span class="dateinline">on Apr 15, 2019</span> </div> </header> <div class="body"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>The Java network programming world has come a long way since Undertow was first started. Netty has emerged as the de-facto standard for network programming in Java, and the Undertow team has decided that the benefits of utilizing Netty outweigh any benefits in keeping our XNIO based transport layer.</p> </div> <div class="paragraph"> <p>Undertow 3.0 will keep Undertow’s programming model, however the underlying transport will be changed from XNIO to Netty. We will also use the Netty HTTP/1, HTTP/2 and Websocket implementations. We believe this change will have a number of advantages:</p> </div> <div class="paragraph"> <p>It will allow other Netty based services (e.g GRPC) to share the same HTTP port It allows sharing of threads between Undertow and other Netty based services, resulting in services using less resources The underlying transport implementation are the most complex part of Undertow, delegating this to Netty will significantly reduce the work needed to maintain Undertow</p> </div> <div class="paragraph"> <p>As part of this Flavia Rainone will be taking over as project lead from Stuart Douglas so he can focus on the recently announced Quarkus project, however Stuart will continue to be heavily involved in Undertow for the foreseeable future.</p> </div> <div class="paragraph"> <p>Flavia Rainone has been involved in JBoss community since 2002 and has an extensive background on Remoting and Xnio. In the past years, she acted as EJB component lead for Wildfly, besides contributing to several projects in Wildfly, such as IronJacamar, JBoss MSC and XNIO, and also Byteman. All this makes her a good fit for taking over Undertow leadership.</p> </div> </div> </div> <div class="sect2"> <h3 id="_what_does_this_mean_for_me">What does this mean for me?</h3> <div class="paragraph"> <p>What this means for you will depend on which parts of Undertow you are using:</p> </div> <div class="paragraph"> <p>If you are using the Servlet API then you will likely not notice any change. You will need some different dependencies (Netty instead of XNIO), however the rest of the experience should be mostly identical If you are using the low level Undertow HttpHandler and HttpServerExchange then you will need to migrate your application. For the most part this migration should be straightforward, as most concepts from the old API directly map to the new API.</p> </div> </div> <div class="sect2"> <h3 id="_road_map">Road Map</h3> <div class="sect3"> <h4 id="_2_x">2.x</h4> <div class="paragraph"> <p>The existing Undertow 2.x branch will continue to be maintained for the foreseeable future. It will receive bug and security fixes, and some features, however it is unlikely to receive any more low level transport oriented features (e.g. HTTP/3 support). For now it is a perfectly valid choice to stay on Undertow 2 while the new Netty based implementation matures.</p> </div> </div> <div class="sect3"> <h4 id="_3_x">3.x</h4> <div class="paragraph"> <p>A 3.0 final version should be released in the next few months, however in the short term the 3.x branch will not provide the same level of API compatibility that Undertow has traditionally provided. As the Netty implementation is new this will allow us to potentially fix any issues we find with our approach without being locked in to supporting an API that is not ideal.</p> </div> <div class="paragraph"> <p>This is a great time to try out the new API and report and problems or suggestions. Note that this is explicitly referring to the core HttpServerExchange based API, no major plans are expected to the Servlet API (i.e. ServletExtension and DeploymentInfo).</p> </div> </div> <div class="sect3"> <h4 id="_4_x">4.x</h4> <div class="paragraph"> <p>After a short 3.x cycle we are planning on releasing a 4.x that will provide API stability, in the same way that Undertow 1.x and 2.x have.</p> </div> </div> </div> <div class="sect2"> <h3 id="_how_can_i_contribute">How can I contribute</h3> <div class="paragraph"> <p>You can contribute to Undertow in the same way it has always been done.</p> </div> <div class="paragraph"> <p>We have an email list open for discussion here: <a href="mailto:undertow-dev@lists.jboss.org">undertow-dev@lists.jboss.org</a></p> </div> <div class="paragraph"> <p>Jira issues can be accessed here: <a href="https://issues.jboss.org/projects/UNDERTOW/issues" class="bare">https://issues.jboss.org/projects/UNDERTOW/issues</a></p> </div> <div class="paragraph"> <p>And source code for 3.x is here: <a href="https://github.com/undertow-io/undertow/tree/3.x" class="bare">https://github.com/undertow-io/undertow/tree/3.x</a></p> </div> <div class="paragraph"> <p>Also, with the move from HipChat to Zulip in Wildfly team, you can now access Undertow stream via Zulip at <a href="https://wildfly.zulipchat.com/" class="bare">https://wildfly.zulipchat.com/</a></p> </div> </div> </div> <div class="footer"> <a href="/blog/2019/04/15/Undertow-3.html">permalink</a> </div> </article> <article class="post"> <header class="header"> <h2 class="title"> <a href="/blog/2018/03/01/Undertow-2.html">Undertow 2.0 released</a> </h2> <div class="byline"> <span class="dateinline">on Mar 01, 2018</span> </div> </header> <div class="body"> <div class="sect1"> <h2 id="_undertow_2_0_released">Undertow 2.0 Released</h2> <div class="sectionbody"> <div class="paragraph"> <p>Undertow 2.0 has been released. This release contains support for Servlet 4.0, which makes it easy to use HTTP/2 features in Servlet applications.</p> </div> <div class="paragraph"> <p>In general it should be backwards compatible with Undertow 1.4, which the exception of dropping support for JDK7.</p> </div> </div> </div> </div> <div class="footer"> <a href="/blog/2018/03/01/Undertow-2.html">permalink</a> </div> </article> <article class="post"> <header class="header"> <h2 class="title"> <a href="/blog/2015/04/27/An-in-depth-overview-of-HTTP2.html">An in depth overview of HTTP/2</a> </h2> <div class="byline"> <span class="dateinline">on Apr 27, 2015</span> </div> </header> <div class="body"> <div class="sect1"> <h2 id="_introduction">Introduction</h2> <div class="sectionbody"> <div class="paragraph"> <p>HTTP/2 is a new protocol, intended as a higher performance alternative to HTTP/1.1. It introduces several new features, while remaining semantically compatible.</p> </div> </div> </div> <div class="sect1"> <h2 id="_key_features">Key Features</h2> <div class="sectionbody"> <div class="paragraph"> <p>HTTP/2 has the following key features compared to HTTP/1.1:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1">Binary Protocol</dt> <dd> <p>HTTP/2 is a binary protocol. This means that it is much more efficient on the wire, however as a result it is no longer human readable without using tools to decode the protocol.</p> </dd> <dt class="hdlist1">Multiplexing</dt> <dd> <p>HTTP/2 supports multiplexing several streams over a single connection. This means that a client can send multiple requests on the same connection, and the server can respond in whatever order the responses become available.</p> </dd> <dt class="hdlist1">Header Compression</dt> <dd> <p>HTTP requests and responses generally include a large number of redundant headers. HTTP/2 uses HPACK header compression to greatly compress headers.</p> </dd> <dt class="hdlist1">Server Push</dt> <dd> <p>Server push allows a server to send additional cacheable resources to the client that the client has not explicitly asked for. The allows the server to anticipate the resources the client will request next and send them eagerly, which saves a round trip.</p> </dd> </dl> </div> </div> </div> <div class="sect1"> <h2 id="_connection_establishment">Connection Establishment</h2> <div class="sectionbody"> <div class="paragraph"> <p>The first part of any usage of HTTP/2 is connection establishment. It would not be practical to allocate a new port just for HTTP/2 for various reasons, so instead the protocol defines 3 different methods of connection that allow the existing HTTP and HTTPS ports to be re-used.</p> </div> <div class="ulist"> <ul> <li> <p>ALPN based connection for https:// URIs</p> </li> <li> <p>HTTP upgrade based connection http:// URIs</p> </li> <li> <p>Connection via prior knowledge for hosts which are known to support HTTP/2</p> </li> </ul> </div> <div class="paragraph"> <p>A detailed explanation of the three is given below. Once the initial connection has been established both the client and server send a connection preface, after which the connection is established.</p> </div> <div class="sect2"> <h3 id="_http_2_connection_methods">HTTP/2 Connection methods</h3> <div class="dlist"> <dl> <dt class="hdlist1">ALPN based connection for https:// URIs</dt> <dd> <p><a href="https://tools.ietf.org/html/rfc7301">ALPN</a> stands for <em>Application Layer Protocol Negotiation</em>, and is a TLS extension that allows a client to negotiate the next protocol to use after the TLS handshake is complete. If either the client or the server does not support ALPN, then it will be ignored, and HTTP/1.1 will be used instead.</p> <div class="literalblock"> <div class="content"> <pre>When the client connects to the server it sends a list of supported protocols. The server will then decide on the next&#x000A;protocol to use and send this back in its response. If the server decides to use HTTP/2 it will send pack 'h2' as the&#x000A;selected protocol, and HTTP/2 will be used for the connection.</pre> </div> </div> </dd> <dt class="hdlist1">HTTP upgrade based connection http:// URIs</dt> <dd> <p>When using this method a client sends a HTTP/1.1 request as normal, however it includes an <code>Upgrade: h2c</code> header that indicates to the server that it wishes to upgrade the connection to HTTP/2.</p> <div class="literalblock"> <div class="content"> <pre>If the server does not understand HTTP/2 or for whatever reason does not wish to use it, it will simply ignore the upgrade&#x000A;request and send a normal HTTP/1.1 response. If the server does decide to upgrade to HTTP/2 then it sends back a HTTP/1.1&#x000A;101 (switching protocols) response, and then after connection establishment has completed sends the response to the&#x000A;original request using HTTP/2.</pre> </div> </div> <div class="literalblock"> <div class="content"> <pre>A client connecting using this method must also include a `HTTP2-Settings` header field, which contains a base 64&#x000A;encoded HTTP/2 settings frame (more on this later).</pre> </div> </div> <div class="literalblock"> <div class="content"> <pre>(NOTE: Firefox and Chrome have both publicly stated that they are not going to support this method, so it remains to be&#x000A; seen if this method will see much real world use).</pre> </div> </div> </dd> <dt class="hdlist1">Connection via prior knowledge for hosts which are known to support HTTP/2</dt> <dd> <p>If it is known that a given host supports HTTP/2 then a client can connect directly by sending a HTTP/2 connection preface. This connection preface is covered in detail below, but it essentially follows the format of HTTP request with <code>PRI</code> as the request method and <code>HTTP/2.0</code> as the protocol, which allows HTTP/1.1 servers to parse it normally. It is not expected that this method will be used on the open internet, however it has its uses (e.g. the Undertow reverse proxy implementation will use it to connect to backend server it knows support HTTP/2).</p> </dd> </dl> </div> </div> <div class="sect2"> <h3 id="_http_2_connection_preface">HTTP/2 connection preface</h3> <div class="paragraph"> <p>Once the initial connection has been established both the client and the server must send a connection preface. The client sends the string <code>PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n</code>, followed by HTTP/2 <code>SETTINGS</code> frame, which may be empty.</p> </div> <div class="paragraph"> <p>The server must send a <code>SETTINGS</code> frame (which may be empty).</p> </div> <div class="paragraph"> <p>Once the connection preface has been exchanged the connection is considered established, and the endpoints can use it to communicate.</p> </div> </div> </div> </div> <div class="sect1"> <h2 id="_wire_format">Wire Format</h2> <div class="sectionbody"> <div class="paragraph"> <p>This post will not go into a in-depth discussion of the wire format, instead we will just give an overview of the basic concepts (if you more details I highly recommend going directly to the <a href="https://http2.github.io/">specification</a>).</p> </div> <div class="paragraph"> <p>HTTP/2 is a framed protocol. All data that is send is part of a frame, which consists of a frame header, followed by some frame data, the format of which depends on the frame type. The maximum size of a frame is 2^24-1 (16,777,215) octets.</p> </div> <div class="paragraph"> <p>A frame header contains the following information:</p> </div> <div class="ulist"> <ul> <li> <p>The frame length</p> </li> <li> <p>The frame type</p> </li> <li> <p>Flags</p> </li> <li> <p>Stream identifier</p> </li> </ul> </div> <div class="paragraph"> <p>The specification defines the following frame types:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1"><code>DATA</code></dt> <dd> <p>Carries the data in a request or response.</p> </dd> <dt class="hdlist1"><code>HEADERS</code></dt> <dd> <p>Used to open a stream (i.e. start a request or response), it contains the headers associated with the request or response</p> </dd> <dt class="hdlist1"><code>PRIORITY</code></dt> <dd> <p>Used to set the priority of a stream</p> </dd> <dt class="hdlist1"><code>RST_STREAM</code></dt> <dd> <p>Forcibly terminates a stream, this is only used if one endpoint decides to cancel a stream, it is not used for normal stream termination</p> </dd> <dt class="hdlist1"><code>SETTINGS</code></dt> <dd> <p>Establishes connection settings for the HTTP/2 connection</p> </dd> <dt class="hdlist1"><code>PUSH_PROMISE</code></dt> <dd> <p>Sent by the server to push a response to the client</p> </dd> <dt class="hdlist1"><code>PING</code></dt> <dd> <p>Sends a ping to the remote endpoint, which must respond with a ping of its own</p> </dd> <dt class="hdlist1"><code>GOAWAY</code></dt> <dd> <p>Sent when an endpoint is going to close the connection</p> </dd> <dt class="hdlist1"><code>WINDOW_UPDATE</code></dt> <dd> <p>Updates the flow control window</p> </dd> <dt class="hdlist1"><code>CONTINUATION</code></dt> <dd> <p>Used to send additional headers if the headers are too large to fit in a single <code>HEADERS</code> frame</p> </dd> </dl> </div> <div class="paragraph"> <p>It is also possible for extensions to define new frame types. An endpoint that does not understand a frame type must simply discard the frame, rather than treating it as an error.</p> </div> </div> </div> <div class="sect1"> <h2 id="_multiplexing">Multiplexing</h2> <div class="sectionbody"> <div class="paragraph"> <p>In HTTP/1.1 requests are essentially processed one at a time. A client sends a request to a server, which generates a response, and once the client has received the response it can send another request to the server. This is not great from a performance point of view. Because only one resource can be requested at a time a single slow resource can delay the rendering of a page. It also does not allow for multiple resources to be generated at the same time.</p> </div> <div class="paragraph"> <p>As a result there are lots of workaround that are used on both the server and browser side to improve performance, including:</p> </div> <div class="ulist"> <ul> <li> <p>Browsers opening multiple connections per host, so multiple resources can requested at once</p> </li> <li> <p>Spriting, where a page with multiple images merges them into a single image, and CSS is used to control the part of the image that is displayed</p> </li> <li> <p>Domain sharding, where resources are served from different subdomains, which allows the browser to open more connections as the browsers internal connection limit is applied per domain</p> </li> <li> <p>HTTP pipelining, where requests are send before responses are relieved, so the server can begin processing them immediately once the current response is done</p> </li> </ul> </div> <div class="paragraph"> <p>HTTP/2 avoids these issues, through the use of multiplexing. This allows multiple requests to be active at once, and the responses can be interleaved on the wire as they become available.</p> </div> <div class="paragraph"> <p>This is done through the concept of streams, in HTTP/2 every request/response pair is mapped to a stream. Each stream is given a unique id. Streams started by the client (most streams) must use odd numbers for the stream identifier, while streams initiated by the server (server push) use even identifiers. Streams are initiated by a <code>HEADERS</code> frame from the client, or a <code>PUSH_PROMISE</code> frame from the server. All HTTP/2 frames include a stream identifier in the header, which allows an endpoint to determine which request the frame belongs to. By default there is no limit to the number of concurrent streams that can be active on a connection, although the server can impose a limit using a <code>SETTINGS</code> frame to limit the amount of server resources a single client can consume.</p> </div> </div> </div> <div class="sect1"> <h2 id="_request_response_overview">Request/Response Overview</h2> <div class="sectionbody"> <div class="paragraph"> <p>At its core HTTP/2 is still a request oriented protocol. A client sends the server a request, the server generates a response and sends it back (server push is obviously an exception to this). This means that it maps cleanly to HTTP/1.1 semantics, so in many cases the application code that is processing a request does not need to know which version of HTTP the wire protocol is using.</p> </div> <div class="paragraph"> <p>A request is started by a client sending a <code>HEADERS</code> frame to open a stream. As you would expect from the name this contains normal HTTP request headers, however it also contains the following pseudo headers:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1"><code>:method</code></dt> <dd> <p>The request method</p> </dd> <dt class="hdlist1"><code>:path</code></dt> <dd> <p>The request path</p> </dd> <dt class="hdlist1"><code>:scheme</code></dt> <dd> <p>The request scheme. Usually either <code>http</code> or <code>https</code></p> </dd> <dt class="hdlist1"><code>:authority</code></dt> <dd> <p>Similar to the HTTP/1.1 <code>Host:</code> header, this contains the authority portion of the target URI (e.g. <a href="http://example.com" class="bare">http://example.com</a>)</p> </dd> </dl> </div> <div class="paragraph"> <p>These pseudo headers must be present and the first headers in the frame. After this the <code>HEADERS</code> frame can contain any number of request headers. If the number of request headers exceeds the maximum frame size then the client can immediately send <code>CONTINUATION</code> frames with additional headers. The last frame containing headers will have the <code>END_HEADERS</code> flag set, which tells the remote endpoint that there is no more headers.</p> </div> <div class="paragraph"> <p>The request can also contain data (e.g. POST requests). If the request has no data the initial <code>HEADERS</code> frame will have the <code>END_STREAM</code> flag set, which tells the server there is no data. Otherwise the server will expect the client to send any number of <code>DATA</code> frames, with the <code>END_STREAM</code> flag set on the last one.</p> </div> <div class="paragraph"> <p>When the server is ready to send a response sequence of frames is similar to when the client sends a request, a single <code>HEADERS</code> frame, followed by optional <code>CONTINUATION</code> frames if the headers do not fit in a single frame, followed by <code>DATA</code> frames for the entity body, however in this case the only pseudo header field is <code>:status</code>, which carries the response status code.</p> </div> <div class="paragraph"> <p>Note that because of the framed structure of HTTP/2 it is no longer necessary (in fact explicitly forbidden) to use the chunked transfer encoding that HTTP/1.1 uses for entities of unknown lengths. If the content length is known it is still recommended to send it in a <code>Content-Length</code> header, even though it is no longer required for the client to know when the request is done it makes for a more user friendly experience (as if this is not present it is not possible for a client to display download progress).</p> </div> </div> </div> <div class="sect1"> <h2 id="_hpack">HPACK</h2> <div class="sectionbody"> <div class="paragraph"> <p>HTTP/2 introduces a form of header compression called HPACK. HPACK allows for very efficient header compression, without being vulnerable to compression related attacks such as CRIME. HPACK provides the following:</p> </div> <div class="ulist"> <ul> <li> <p>The ability to encode large headers using a fixed Huffman encoding</p> </li> <li> <p>The ability to encode commonly used headers as a variable length integer, rather than re-sending the whole header each time</p> </li> </ul> </div> <div class="paragraph"> <p>All headers sent via HTTP/2 (in <code>HEADERS</code>, <code>CONTINUATION</code> and <code>PUSH_PROMISE</code> frames) are sent in the HPACK format.</p> </div> <div class="paragraph"> <p>HPACK works by having both endpoints maintain a copy of a header table (the <em>dynamic table</em>). When an endpoint sends a header to the remote endpoint it can instruct the remote endpoint to store it in its dynamic table. If the endpoint needs to send the same header again it can just send its index in the dynamic table, instead of sending the whole header. The size of the dynamic table is limited to 4k by default, however larger or smaller limits can be set using a <code>SETTINGS</code> frame.</p> </div> <div class="paragraph"> <p>As many requests and responses will contain the same headers, this technique is very effective, as after the first request most headers will be represented as an integer index into the dynamic or static table.</p> </div> <div class="paragraph"> <p>HPACK also defines a <em>static table</em> which is a pre defined table of commonly used headers, so HPACK will provide some compression even before the dynamic table is populated.</p> </div> <div class="paragraph"> <p>HPACK also allows header names and values to be encoded via a fixed Huffman encoding. Because this encoding uses a fixed encoding table, it is not vulnerable to compression based attacks such as CRIME.</p> </div> </div> </div> <div class="sect1"> <h2 id="_server_push">Server Push</h2> <div class="sectionbody"> <div class="paragraph"> <p>First introduced in the SPDY protocol, server push allows a server to send unsolicited request+response pairs to a client. Generally this will be used to immediately begin sending resources that a server expects a client based on the current request. For example if a client requests <code>/index.html</code>, and the server knows that <code>/index.html</code> contains a reference to <code>/logo.png</code> the server might decide to immediately push <code>logo.png</code> rather than waiting for the client to request it.</p> </div> <div class="paragraph"> <p>To push a response to the client the server opens a stream using a <code>PUSH_PROMISE</code> frame, which contains the complete set of request header fields that the server attributes to the request (this includes pseudo headers, such as <code>:path</code>, which let the client know exactly which resource is being pushed). A <code>PUSH_PROMISE</code> frame must be associated with an existing client request, so the client knows which request caused the server to initiate the push. After the <code>PUSH_PROMISE</code> frame has been send the server may begin sending <code>HEADERS</code> followed by <code>DATA</code> frames, as it would for a normal response.</p> </div> <div class="paragraph"> <p>Pushed resources must be <a href="http://tools.ietf.org/html/rfc7234">cacheable</a>. In practice this means that pushed requests will generally be limited to <code>GET</code> requests with a response that contains headers that allow for caching.</p> </div> <div class="paragraph"> <p>If a server pushes a request for a resource that the client knows it does not need (for example it may already have the resource in its cache) the client can send a <code>RST_STREAM</code> frame to the server to cancel the pushed request.</p> </div> <div class="paragraph"> <p>Note that there is no foolproof way to know exactly what should be pushed, as there is know way to know exactly what a client has in its cache. Initiating a large number of pushes for resources that the client already has cached is obviously not ideal, as it can waste server resources and bandwidth (even if the client does <code>RST_STREAM</code> the pushed request, the server will may have already allocated resources to servicing the push request).</p> </div> </div> </div> <div class="sect1"> <h2 id="_priority">Priority</h2> <div class="sectionbody"> <div class="paragraph"> <p>Priority is a new concept that HTTP/2 introduces to allow a client to give priority preferences to particular streams. Priority is non binding, and a server is free to ignore it completely.</p> </div> <div class="paragraph"> <p>The priority mechanism is expressed in terms of stream dependencies and weights. A stream can be given a dependency on another stream, which tells the server that it should allocate resources to the identified stream instead of the dependent stream (conceptually all streams are considered to depend on another stream, streams with no explicit dependency depend on the virtual stream 0).</p> </div> <div class="paragraph"> <p>According to the spec a server should only allocate resources to a dependent stream if all its dependencies (and their dependencies) are either closed or it is not possible to make progress on them.</p> </div> <div class="paragraph"> <p>Dependent streams can also be given a weight, between 1 and 256, and resources should be allocated on a proportional basis. For example if stream A and B have a dependency on C, and A has a weighting of 1 and B has a weighting of 10 then B should receive 10 times amount of server resources as A.</p> </div> <div class="paragraph"> <p>Dependencies and weightings can be set at stream creation time, and modified afterwards with a <code>PRIORITY</code> frame.</p> </div> <div class="paragraph"> <p>Note that due to the complexity of implementing this on the server side it is unlikely that many implementations will be able to allocate resources and prioritise as the spec specifies. In general once a request has started being processed in most cases a server does not have control over how CPU and other resources (database connection etc) are processed. In practice servers will likely be able to prioritise frames from higher priority streams if multiple frames are ready at the same time, and if streams are being queued for execution processes higher priority streams over lower priority ones, but in general a client cannot rely on priority as being anything other than a suggestion.</p> </div> </div> </div> <div class="sect1"> <h2 id="_flow_control">Flow Control</h2> <div class="sectionbody"> <div class="paragraph"> <p>HTTP/2 has the concept of a credit based flow control mechanism. Every stream, and the connection as a whole maintains a send window, which is the amount of data that the server is allowed to send on the stream/connection. Once this window is exhausted no more data can be sent, until the remote endpoint sends a <code>WINDOW_UPDATE</code> frame that increases the send window size. This additional flow control window is on top of the flow control already provided by TCP. The default window size is 65,535 bytes, however many implementation will increase this in the initial <code>SETTINGS</code> frame. Flow control only applies to <code>DATA</code> frames.</p> </div> <div class="paragraph"> <p>To understand why this is necessary consider a server handling a large POST request from a client. The server basically acts as an intermediary between the network and some web application, if the web application is slow to read this POST data, then as a server we only have two options:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1">Buffer a potentially unbounded amount of data</dt> <dd> <p>In this scenario the client keeps sending data, and we keep storing it in memory waiting for the web application to ask for it. This has the potential for a misbehaving or malicious client to make the server run out of memory.</p> </dd> <dt class="hdlist1">Stop reading from the underlying socket</dt> <dd> <p>Once we have buffered a certain amount of data we could simply stop reading from the underlying socket until the end user application empties the buffer. Unfortunately this means that all other requests will also be blocked (head of line blocking), which negates a lot of the benefits of multiplexing.</p> </dd> </dl> </div> <div class="paragraph"> <p>Flow control allows us to limit the amount of data that is sent for any given stream, essentially allowing us to pause the stream until the web application actually starts reading data. If we don&#8217;t send <code>WINDOW_UPDATE</code> frames for a stream until the web application has actually consumed the data then we know that the maximum amount of data we will need to buffer per stream is equivalent to the window size (which we can control through a <code>SETTINGS</code> frame).</p> </div> <div class="paragraph"> <p>Without flow control an endpoint has no effective way of managing the amount of data it may need to buffer.</p> </div> <div class="paragraph"> <p>Something to note is that the flow control window can be different in each direction. For example a resource constrained server may set a small flow control window size to prevent the client from flooding it with a large amount of data, while the client may set a large flow control window for maximum performance. In this case the server can send a large amount of data before receiving a <code>WINDOW_UPDATE</code>, while the client will only be able to send a small amount.</p> </div> <div class="paragraph"> <p>Note that flow control should not be used as a priority mechanism (HTTP/2 already has the concept of stream priority for this). In particular a deadlock can result if a client stops sending <code>WINDOW_UPDATE</code> frames on a stream1 because it wants a server to prioritise stream2, and the server has decided not to allocate resources to stream2 until stream1 is complete.</p> </div> </div> </div> <div class="sect1"> <h2 id="_settings">Settings</h2> <div class="sectionbody"> <div class="paragraph"> <p>The HTTP/2 settings frame is used to establish settings that are used to control each side of the connection. Each endpoint sends its own settings, which may be different which means the settings may be different for depending on the direction of communication (e.g. the maximum frame size can be different depending on if they are sent by the client or the server).</p> </div> <div class="paragraph"> <p>The specification defines the following settings:</p> </div> <div class="dlist"> <dl> <dt class="hdlist1"><code>SETTINGS_HEADER_TABLE_SIZE</code></dt> <dd> <p>The maximum allowed size of the HPACK header table. Defaults to 4,096.</p> </dd> <dt class="hdlist1"><code>SETTINGS_ENABLE_PUSH</code></dt> <dd> <p>A setting that is sent from the client to the server, if this is enabled then the server is allowed to push responses to the client, default to true.</p> </dd> <dt class="hdlist1"><code>SETTINGS_MAX_CONCURRENT_STREAMS</code></dt> <dd> <p>The maximum number of concurrent streams that can be opened, basically this corresponds to the number of requests that can be active at the same time. By default this is unlimited.</p> </dd> <dt class="hdlist1"><code>SETTINGS_INITIAL_WINDOW_SIZE</code></dt> <dd> <p>The initial window size that is used for flow control. Defaults to 65,535.</p> </dd> <dt class="hdlist1"><code>SETTINGS_MAX_FRAME_SIZE</code></dt> <dd> <p>The maximum allowed frame size that the remote endpoint is prepared to accept. Defaults to 16,384.</p> </dd> <dt class="hdlist1"><code>SETTINGS_MAX_HEADER_LIST_SIZE</code></dt> <dd> <p>This setting advises the remote endpoint of the maximum size of the header list the remote endpoint will accept. The default value is unlimited.</p> </dd> </dl> </div> </div> </div> </div> <div class="footer"> <a href="/blog/2015/04/27/An-in-depth-overview-of-HTTP2.html">permalink</a> </div> </article> <article class="post"> <header class="header"> <h2 class="title"> <a href="/blog/2015/03/26/HTTP2-In-Wildfly.html">Using HTTP2 With Wildfly 9.0.0.Beta1</a> </h2> <div class="byline"> <span class="dateinline">on Mar 26, 2015</span> </div> </header> <div class="body"> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>The upcoming Wildfly 9.0.0.Beta1 release supports HTTP2, which includes new features like request multiplexing and server push, unfortunately due to a few different factors it is not as straightforward to set up as HTTP1. The complexity comes because HTTP2 as implemented by major browsers requires the use of TLS. This is further complicated by the fact that it does not use straight TLS, but requires a extension called ALPN (application layer protocol negotiation).</p> </div> <div class="paragraph"> <p>Support for ALPN will be coming in Java 9, however unfortunately it is not present in JDK7 or JDK8. To get around this we need to install a jar that provides ALPN support into the JVM&#8217;s boot class path. The version of the jar file that you need is tied to the JVM version in use, so you must make sure you are using the correct version for you JVM.</p> </div> <div class="paragraph"> <p>Note that you must use JDK8 to use HTTP2, as HTTP2 requires stronger cyphers than are present in JDK7.</p> </div> <div class="paragraph"> <p><strong>IMPORTANT</strong>: The script and instructions below are just using a self signed certificate that is present in the Undertow test suite to get you started. <strong>DO NOT USE THIS CERTIFICATE IN PRODUCTION.</strong> You should get a real certificate signed by a trusted certificate authority.</p> </div> </div> </div> <div class="sect1"> <h2 id="_the_tl_dr_version">The TL;DR version</h2> <div class="sectionbody"> <div class="paragraph"> <p>Make sure you are using <strong>JDK 1.8.0u40</strong>, then run the script below. This will (hopefully) perform all the steps that are required to setup Wildfly.</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight"><code class="language-bash" data-lang="bash">#!/bin/bash&#x000A;&#x000A;if [ "x$JBOSS_HOME" == "x" ]; then&#x000A;	echo "JBOSS_HOME is not set, please set it to the root of your Wildfly installation"&#x000A;	exit&#x000A;fi&#x000A;&#x000A;cd $JBOSS_HOME&#x000A;&#x000A;#IMPORTANT: The ALPN version changes depending on the version of the JVM you are using&#x000A;#If you see class not found or similar SSL errors please look up the correct version&#x000A;# at http://eclipse.org/jetty/documentation/current/alpn-chapter.html&#x000A;ALPN_VERSION=8.1.3.v20150130&#x000A;&#x000A;#download our fake certificate for testing&#x000A;#DO NOT USE THIS IN PRODUCTION&#x000A;#Get a real cert instead&#x000A;curl https://raw.githubusercontent.com/undertow-io/undertow/master/core/src/test/resources/server.keystore &gt;standalone/configuration/server.keystore&#x000A;curl https://raw.githubusercontent.com/undertow-io/undertow/master/core/src/test/resources/server.truststore &gt;standalone/configuration/server.truststore&#x000A;&#x000A;#Download the ALPN jar we are interested in&#x000A;curl http://central.maven.org/maven2/org/mortbay/jetty/alpn/alpn-boot/$ALPN_VERSION/alpn-boot-$ALPN_VERSION.jar &gt;bin/alpn-boot-$ALPN_VERSION.jar&#x000A;&#x000A;#Add ALPN to the boot class path&#x000A;echo 'JAVA_OPTS="$JAVA_OPTS' " -Xbootclasspath/p:$JBOSS_HOME/bin/alpn-boot-$ALPN_VERSION.jar" '"' &gt;&gt;bin/standalone.conf&#x000A;&#x000A;#Start Wildfly in the background&#x000A;./bin/standalone.sh &amp;&#x000A;#wait for Wildfly to start&#x000A;sleep 15&#x000A;&#x000A;#Add a HTTPS connector&#x000A;./bin/jboss-cli.sh -c "--command=/core-service=management/security-realm=https:add()"&#x000A;./bin/jboss-cli.sh -c "--command=/core-service=management/security-realm=https/authentication=truststore:add(keystore-path=server.truststore, keystore-password=password, keystore-relative-to=jboss.server.config.dir)"&#x000A;./bin/jboss-cli.sh -c "--command=/core-service=management/security-realm=https/server-identity=ssl:add(keystore-path=server.keystore, keystore-password=password, keystore-relative-to=jboss.server.config.dir)"&#x000A;./bin/jboss-cli.sh -c "--command=/subsystem=undertow/server=default-server/https-listener=https:add(socket-binding=https, security-realm=https, enable-http2=true)"&#x000A;&#x000A;#shut down Wildfly&#x000A;kill `jps | grep jboss-modules.jar | cut -f1 -d ' ' `</code></pre> </div> </div> </div> </div> <div class="sect1"> <h2 id="_a_step_by_step_guide">A step by step guide</h2> <div class="sectionbody"> <div class="dlist"> <dl> <dt class="hdlist1">Figure out the correct Jetty ALPN Jar for your JDK version</dt> <dd> <p>Have a look at <a href="http://eclipse.org/jetty/documentation/current/alpn-chapter.html" class="bare">http://eclipse.org/jetty/documentation/current/alpn-chapter.html</a> to figure out which version of Jetty ALPN is required for your JVM version. Download the correct jar version from <a href="http://central.maven.org/maven2/org/mortbay/jetty/alpn/alpn-boot/">maven central</a> and place it in the Wildfly bin directory.</p> </dd> <dt class="hdlist1">Add ALPN to the boot class path</dt> <dd> <p>Edit standalone.conf and add the following line to the JAVA_OPTS environment variable (making appropriate substitutions for the ALPN version). <code>-Xbootclasspath/p:$JBOSS_HOME/bin/alpn-boot-$ALPN_VERSION.jar</code></p> </dd> <dt class="hdlist1">Get a SSL certificate and create a keystore and truststore</dt> <dd> <p>For testing purposes you can download the ones from the Undertow test suite that are linked in the script above. For production use you will need to create a certificate and get it signed by a certificate authority. For the purposes of these instructions we assume they are located in standalone/configuration/server.[keystore|truststore].</p> </dd> <dt class="hdlist1">Start Wildfly</dt> <dd> <p>We are going to make the remaining changes using the CLI, which means Wildfly must be started.</p> </dd> <dt class="hdlist1">Connect to Wildfly using the CLI</dt> <dd> <p>Run the following command to connect: <code>$JBOSS_HOME/bin/jboss-cli.sh -c</code>.</p> </dd> <dt class="hdlist1">Add a security realm</dt> <dd> <p>This contains the configuration that is used to tell the HTTPS connector which certificates to use.</p> </dd> </dl> </div> <div class="listingblock"> <div class="content"> <pre class="highlight"><code>/core-service=management/security-realm=https:add()&#x000A;/core-service=management/security-realm=https/authentication=truststore:add(keystore-path=server.truststore, keystore-password=password, keystore-relative-to=jboss.server.config.dir)&#x000A;/core-service=management/security-realm=https/server-identity=ssl:add(keystore-path=server.keystore, keystore-password=password, keystore-relative-to=jboss.server.config.dir)</code></pre> </div> </div> <div class="dlist"> <dl> <dt class="hdlist1">Add a HTTPS connector</dt> </dl> </div> <div class="listingblock"> <div class="content"> <pre class="highlight"><code>/subsystem=undertow/server=default-server/https-listener=https:add(socket-binding=https, security-realm=https, enable-http2=true)</code></pre> </div> </div> <div class="dlist"> <dl> <dt class="hdlist1">Test it out</dt> <dd> <p>Fire up Chrome and head to <a href="https://localhost:8443">https://localhost:8443</a>. After clicking through the security warning about the self signed certificate you should see the normal Wildfly welcome page. Open up the developer tools and have a look in the <em>Network</em> tab. In the request headers section you should see chrome sending HTTP2 pseudo headers (:path, :authority, :method and :scheme). You can also look in the <code>chrome://net-internals</code> page, and you should be able to see the details of the HTTP2 session (although it will show up as a SPDY_SESSION event, as internally Chrome has been referring to HTTP2 as SPDY4).</p> </dd> </dl> </div> </div> </div> </div> <div class="footer"> <a href="/blog/2015/03/26/HTTP2-In-Wildfly.html">permalink</a> </div> </article> <ul class="pager"> <li class="previous"> <a href="/blog/page/2.html">&laquo; Older</a> </li> <li class="pages">Page 1 of 2</li> <li class="disabled next"> <a href="#">Newer &raquo;</a> </li> </ul> <div id="companyfooter-placeholder"></div> </div> <div class="container" id="companyfooter"> <div class="redhatlogo"> <div id="logospacer"></div> <a href="https://www.redhat.com/"><img src="https://static.jboss.org/theme/images/common/redhat_logo.png"></a> </div> </div> <script src="https://static.jboss.org/wildfly/scripts/bootstrap-community.min.js"></script> <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-61374382-1', 'auto');
  ga('send', 'pageview');
</script> </body> </html>